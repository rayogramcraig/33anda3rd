<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>33⅓ – Label Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- iOS: run as a standalone "web app" when added to Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="33anda3rd" />

  <!-- Nice-to-have: theme colors (Android + some browsers) -->
  <meta name="theme-color" content="#b40000" />

  <!-- Favicons -->
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">

  <!-- iOS Home Screen icon (important: iOS prefers this over manifest icons) -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png" sizes="180x180" />

  <!-- PWA manifest (helps Android + iOS 16.4+; still keep apple-touch-icon) -->
  <link rel="manifest" href="manifest.webmanifest" />

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
  <link rel="stylesheet" href="https://use.typekit.net/zxp4dru.css">

  <style>
    :root {
      --accent-red: #d40000;
      --accent-yellow: #ffe400;
      --text-main: #ffffff;
      --shadow-strong: 0 18px 30px rgba(0, 0, 0, 0.45);
      --shadow-soft: 0 8px 18px rgba(0, 0, 0, 0.35);
      --font-main: "coolvetica", "SF Pro Text", "Helvetica Neue", Arial, sans-serif;

      /* NEW: dynamic results gradient color (RGB components) */
      --results-rgb: 180, 0, 0;
    }

    *, *::before, *::after { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; }

    body {
      font-family: var(--font-main);
      color: #000;
      background-color: #d9c4a8; /* fallback */
      background-image: url("maple.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    .app {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      border-radius: 0;
      box-shadow: none;
      background: transparent; /* let the wood show through */
    }

    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 56px 24px 28px;
      transition: opacity 220ms ease-out, transform 220ms ease-out;
    }
    .screen-default { opacity: 1; transform: translateX(0); }
    .screen-processing, .screen-results {
      opacity: 0;
      transform: translateX(100%);
      pointer-events: none;
    }

    .app:not(.show-processing):not(.show-results) .screen-default {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    .app.show-processing .screen-default,
    .app.show-results .screen-default {
      opacity: 0;
      transform: translateX(-100%);
      pointer-events: none;
    }
    .app.show-processing .screen-processing {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    .app.show-results .screen-processing {
      opacity: 0;
      transform: translateX(-100%);
      pointer-events: none;
    }
    .app.show-results .screen-results {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    /* DEFAULT SCREEN */

    .screen-default h1 {
      margin: 0 0 40px;
      font-size: 28px;
      letter-spacing: 0.03em;
      font-weight: 700;
      text-align: center;
    }
    .record-wrapper {
      position: relative;
      width: 76%;
      max-width: 320px;
      margin-top: 20px;
    }
    .record {
      position: relative;
      width: 100%;
      padding-bottom: 58%;
      border-radius: 50%;
      background: radial-gradient(ellipse at 30% 28%, #777 0%, #222 55%, #020202 100%);
      transform: rotate(-18deg);
      box-shadow: var(--shadow-soft);
    }
    .record::before {
      content: "";
      position: absolute;
      inset: 12% 8%;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(255,255,255,0.22), rgba(255,255,255,0));
      opacity: 0.55;
      mix-blend-mode: screen;
    }
    .record-label {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 34%;
      height: 34%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }
    .record-label::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 6px;
      margin-top: -3px;
      margin-left: -3px;
      border-radius: 50%;
      background: #000;
    }
    .label-beam {
      position: absolute;
      top: -110px;
      left: 50%;
      width: 3px;
      height: 150px;
      background: var(--accent-yellow);
      transform-origin: top center;
      border-radius: 999px;
      visibility: hidden;
    }
    .label-beam.left { transform: translateX(-50%) rotate(-8deg); }
    .label-beam.right { transform: translateX(-50%) rotate(8deg); }

    .capture-hit-area {
      position: absolute;
      inset: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }

    /* PROCESSING SCREEN */

    .screen-processing h1 {
      margin: 0 0 32px;
      font-size: 24px;
      letter-spacing: 0.0em;
      text-align: center;
    }
    .processing-record-wrapper {
      position: relative;
      width: 76%;
      max-width: 320px;
      margin-top: 10px;
    }

    /* Tonearm overlay on scanning record – tuned to sit beside the record */
    .tonearm {
      position: absolute;
      width: 52%;
      right: -18%;
      top: 8%;
      transform: rotate(18deg);
      pointer-events: none;
      z-index: 10;
    }

    /* Flattened, circular record on processing screen */
    .processing-record-wrapper .record {
      padding-bottom: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #777 0%, #222 55%, #020202 100%);
      transform: none;
    }

    .record.spinning {
      transform: none;
      animation: spin 1.4s linear infinite;
    }

    /* label texture on processing record */
    .screen-processing .record-label {
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    .processing-label-text {
      margin-top: 32px;
      font-size: 14px;
      letter-spacing: 0.0em;
      font-weight: 400;
      opacity: 0.8;
    }
    .processing-status { margin-top: 8px; font-size: 13px; }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    /* RESULTS SCREEN */

    .screen-results { padding: 0; }

    .results-top {
      position: relative;
      flex: 0 0 56%;
      width: 100%;
      overflow: hidden;
    }
    .album-art {
      position: absolute;
      inset: 0;
      background: #e0e0e0;
    }
    .album-art img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .album-label-circle {
      position: absolute;
      left: 50%;
      top: 52%;
      width: 46%;
      padding-bottom: 46%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      box-shadow: var(--shadow-strong);
    }
    .album-label-circle::before {
      content: "";
      position: absolute;
      inset: 10%;
      border-radius: 50%;
      border: 3px solid rgba(255,220,150,0.8);
    }
    .album-label-circle::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 8px;
      height: 8px;
      margin-left: -4px;
      margin-top: -4px;
      border-radius: 50%;
      background: #111;
    }

    .results-bottom {
      position: relative;
      flex: 1;
      width: 100%;

      /* NEW: gradient driven by --results-rgb */
      background:
        linear-gradient(
          to bottom,
          rgba(var(--results-rgb), 0.95) 0%,
          rgba(var(--results-rgb), 0.95) 48%,
          rgba(var(--results-rgb), 0.40) 80%,
          rgba(var(--results-rgb), 0.00) 100%
        ),
        url("maple.png") center/cover no-repeat;

      padding: 24px 24px 26px;
      color: #fff;
    }

    .album-meta { padding-right: 32%; }
    .album-meta h2,
    .album-meta h3 {
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.03em;
    }
    .album-meta h2 { font-size: 24px; line-height: 1.1; margin-bottom: 10px; }
    .album-meta h3 { font-size: 24px; line-height: 1.1; }

    /* Bottom row: evenly spaced controls */
    .results-bottom-row {
      position: absolute;
      left: 24px;
      right: 24px;
      bottom: 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 18px;
    }

    /* Info button in the row */
    .info-button {
      flex: 0 0 auto;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      background: #ffffff;
      color: var(--accent-red);
      font-style: italic;
      font-size: 32px;
      line-height: 60px;
      text-align: center;
      box-shadow: var(--shadow-soft);
      cursor: pointer;
    }

    .retake-button {
      border: none;
      padding: 0;
      background: transparent;
      cursor: pointer;
      flex: 0 0 auto;
    }

    /* New flat mini-record used on results screen */
    .mini-record {
      position: relative;
      width: 88px;
      padding-bottom: 88px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #777 0%, #222 55%, #020202 100%);
      transform: none;
      box-shadow: var(--shadow-soft);
    }
    .mini-record::before {
      content: "";
      position: absolute;
      inset: 12% 10%;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(255,255,255,0.2), transparent);
      opacity: 0.6;
    }
    .mini-label {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 34%;
      height: 34%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: #fff;
    }
    .mini-label::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 5px;
      height: 5px;
      margin-left: -2.5px;
      margin-top: -2.5px;
      border-radius: 50%;
      background: #000;
    }

    .discogs-button {
      border: none;
      border-radius: 999px;
      padding: 14px 26px 14px 24px;
      background: #ffffff;
      color: var(--accent-red);
      font-weight: 700;
      font-size: 20px;
      letter-spacing: 0.04em;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
      flex: 0 0 auto;
      white-space: nowrap;
    }
    .discogs-button .play-icon {
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-left: 12px solid var(--accent-red);
    }

    /* OVERLAY */

    .results-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 32px 22px;
      color: #222;
    }
    .results-overlay.open { display: flex; }

    .overlay-card {
      width: 100%;
      max-width: 360px;
      background: #ffffff;
      border-radius: 22px;
      padding: 18px 18px 16px;
      box-shadow: 0 18px 35px rgba(0,0,0,0.5);
      font-size: 14px;
    }
    .overlay-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .overlay-card-header h4 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .overlay-close {
      border: none;
      background: transparent;
      font-size: 22px;
      cursor: pointer;
    }
    .overlay-body {
      font-size: 13px;
      line-height: 1.35;
      max-height: 280px;
      overflow-y: auto;
    }
    .overlay-body .meta-line { margin-top: 4px; }

    .overlay-label {
      margin-top: 10px;
      font-weight: 600;
      margin-bottom: 2px;
    }
    .overlay-ocr {
      white-space: pre-wrap;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      background: #f5f5f5;
      border-radius: 10px;
      padding: 8px;
      margin-top: 4px;
    }

    .overlay-discogs {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
    }
    .overlay-discogs button {
      border: none;
      border-radius: 999px;
      padding: 8px 18px;
      font-size: 14px;
      background: var(--accent-red);
      color: #fff;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    .overlay-discogs .play-icon {
      width: 0;
      height: 0;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      border-left: 9px solid #fff;
    }

    .meta-line {
      font-size: 12px;
      color: #555;
    }

    @media (max-height: 720px) {
      .screen { padding-top: 42px; }
      .screen-default h1 {
        margin-bottom: 26px;
        font-size: 24px;
      }
    }

    #labelCanvas { display: none; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <input
      type="file"
      id="fileInput"
      accept="image/*"
      capture="environment"
      style="display: none"
    />

    <!-- DEFAULT -->
    <section class="screen screen-default" aria-label="Shoot the label">
      <h1>just the label</h1>
      <div class="record-wrapper">
        <div class="record">
          <div class="record-label"></div>
        </div>
        <div class="label-beam left"></div>
        <div class="label-beam right"></div>
      </div>
      <button class="capture-hit-area" type="button" aria-label="Shoot the label"></button>
    </section>

    <!-- PROCESSING -->
    <section class="screen screen-processing" aria-label="Processing label">
      <h1>Finding your record</h1>
      <div class="processing-record-wrapper">
        <div class="record spinning">
          <div class="record-label"></div>
        </div>
        <img class="tonearm" src="tonearm.png" alt="" />
      </div>
      <div class="processing-label-text">analyzing the label…</div>
      <div class="processing-status" id="processingStatus">Loading image…</div>
    </section>

    <!-- RESULTS -->
    <section class="screen screen-results" aria-label="Scan results">
      <div class="results-top">
        <div class="album-art">
          <!-- IMPORTANT: no crossorigin here, so the cover always displays -->
          <img id="discogsCover" alt="Album cover" />
        </div>
        <div class="album-label-circle"></div>
      </div>

      <div class="results-bottom">
        <div class="album-meta">
          <h2 id="albumArtist">Artist</h2>
          <h3 id="albumTitle">Title</h3>
        </div>

        <div class="results-bottom-row">
          <button class="retake-button" type="button" id="retakeButton" aria-label="Shoot another label">
            <div class="mini-record">
              <div class="mini-label"></div>
            </div>
          </button>

          <button class="info-button" type="button" id="infoButton" aria-label="Show technical results">i</button>

          <button class="discogs-button" type="button" id="discogsButton" aria-label="Open release on Discogs">
            <span class="play-icon" aria-hidden="true"></span>
            <span>Discogs</span>
          </button>
        </div>
      </div>

      <div class="results-overlay" id="resultsOverlay" aria-hidden="true">
        <div class="overlay-card">
          <div class="overlay-card-header">
            <h4>Scan details</h4>
            <button class="overlay-close" type="button" id="overlayClose" aria-label="Close details">&times;</button>
          </div>
          <div class="overlay-body">
            <div class="meta-line" id="statusText">Waiting for a photo…</div>
            <div class="meta-line" id="matchStatus"></div>
            <div class="meta-line" id="googleQueryLine"></div>
            <div class="meta-line" id="cleanQueryLine"></div>

            <div class="overlay-label">OCR text</div>
            <div class="overlay-ocr" id="ocrOutput"></div>
          </div>
          <div class="overlay-discogs">
            <button type="button" id="overlayDiscogsButton">
              <span class="play-icon" aria-hidden="true"></span>
              <span>Open on Discogs</span>
            </button>
          </div>
        </div>
      </div>
    </section>

    <canvas id="labelCanvas"></canvas>
  </div>

  <script>
    const app = document.getElementById("app");
    const fileInput = document.getElementById("fileInput");
    const captureHitArea = document.querySelector(".capture-hit-area");
    const retakeButton = document.getElementById("retakeButton");

    const canvas = document.getElementById("labelCanvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    const statusText = document.getElementById("statusText");
    const matchStatus = document.getElementById("matchStatus");
    const ocrOutput = document.getElementById("ocrOutput");
    const cleanQueryLine = document.getElementById("cleanQueryLine");
    const googleQueryLine = document.getElementById("googleQueryLine");
    const processingStatus = document.getElementById("processingStatus");

    const discogsCover = document.getElementById("discogsCover");
    const albumArtist = document.getElementById("albumArtist");
    const albumTitle = document.getElementById("albumTitle");
    const discogsButton = document.getElementById("discogsButton");
    const overlayDiscogsButton = document.getElementById("overlayDiscogsButton");

    const infoButton = document.getElementById("infoButton");
    const overlay = document.getElementById("resultsOverlay");
    const overlayClose = document.getElementById("overlayClose");

    // elements that get the label texture
    const processingRecordLabel = document.querySelector(".screen-processing .record-label");
    const albumLabelCircle = document.querySelector(".album-label-circle");

    let currentDiscogsUrl = "";
    let currentGoogleQuery = "";

    // NEW: keep the label crop data URL for color sampling
    let currentLabelDataUrl = "";

    // NEW: a temporary cover sampler image (CORS-enabled attempt)
    let coverSamplerImg = null;

    captureHitArea.addEventListener("click", () => fileInput.click());

    retakeButton.addEventListener("click", () => {
      overlay.classList.remove("open");
      overlay.setAttribute("aria-hidden", "true");
      app.classList.remove("show-results");
      app.classList.remove("show-processing");

      // reset label textures
      if (processingRecordLabel) {
        processingRecordLabel.style.backgroundImage = "";
        processingRecordLabel.style.backgroundColor = "#fff";
      }
      if (albumLabelCircle) {
        albumLabelCircle.style.backgroundImage = "";
      }

      currentLabelDataUrl = "";
      coverSamplerImg = null;
      setResultsAccentRgb([180, 0, 0]);

      fileInput.value = "";
      fileInput.click();
    });

    fileInput.addEventListener("change", () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;

      app.classList.add("show-processing");
      app.classList.remove("show-results");

      matchStatus.textContent = "";
      ocrOutput.textContent = "";
      cleanQueryLine.textContent = "";
      googleQueryLine.textContent = "";
      processingStatus.textContent = "Loading image…";
      statusText.textContent = "Loading image…";
      currentDiscogsUrl = "";
      currentGoogleQuery = "";
      discogsCover.removeAttribute("src");

      currentLabelDataUrl = "";
      coverSamplerImg = null;
      setResultsAccentRgb([180, 0, 0]);

      // reset label textures
      if (processingRecordLabel) {
        processingRecordLabel.style.backgroundImage = "";
        processingRecordLabel.style.backgroundColor = "#fff";
      }
      if (albumLabelCircle) {
        albumLabelCircle.style.backgroundImage = "";
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => processImage(img);
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

    function processImage(img) {
      const size = Math.min(img.width, img.height);
      const sx = (img.width - size) / 2;
      const sy = (img.height - size) / 2;

      canvas.width = size;
      canvas.height = size;

      // Draw the cropped, COLOR square first
      ctx.drawImage(img, sx, sy, size, size, 0, 0, size, size);

      // Use that crop as the label texture on both records
      try {
        const labelDataUrl = canvas.toDataURL("image/png");
        currentLabelDataUrl = labelDataUrl;

        if (processingRecordLabel) {
          processingRecordLabel.style.backgroundImage = `url(${labelDataUrl})`;
          processingRecordLabel.style.backgroundColor = "transparent";
        }
        if (albumLabelCircle) {
          albumLabelCircle.style.backgroundImage = `url(${labelDataUrl})`;
        }

        // NEW: update gradient immediately based on the label
        updateResultsGradient();
      } catch (e) {
        console.error("Error creating label data URL", e);
      }

      // Now convert the same crop to grayscale for OCR
      const imageData = ctx.getImageData(0, 0, size, size);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
        data[i] = data[i + 1] = data[i + 2] = gray;
      }
      ctx.putImageData(imageData, 0, 0);

      processingStatus.textContent = "Running OCR…";
      statusText.textContent = "Running OCR…";
      runOCR();
    }

    function buildCleanQuery(rawText) {
      const lines = rawText.split(/\r?\n/);
      const tokens = [];
      for (let line of lines) {
        line = line
          .replace(/[^A-Za-z0-9'&()\- ]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();
        if (!line) continue;
        const words = line.split(" ");
        const goodWords = words.filter((w) => {
          if (!w) return false;
          if (/^\d+$/.test(w)) return true;
          return w.length > 2;
        });
        if (goodWords.length) tokens.push(...goodWords);
      }
      const seen = new Set();
      const final = [];
      for (let w of tokens) {
        const key = w.toUpperCase();
        if (!seen.has(key)) {
          seen.add(key);
          final.push(w);
        }
      }
      return final.join(" ");
    }

    async function runOCR() {
      try {
        const { data } = await Tesseract.recognize(canvas, "eng", {
          logger: (m) => {
            if (m.status === "recognizing text" && m.progress != null) {
              const pct = Math.round(m.progress * 100);
              const msg = `Running OCR… ${pct}%`;
              processingStatus.textContent = msg;
              statusText.textContent = msg;
            }
          },
        });

        const text = data.text || "";
        ocrOutput.textContent = text.trim();
        processingStatus.textContent = "OCR complete. Trying to identify record…";
        statusText.textContent = "OCR complete. Trying to identify record…";

        const cleanQuery = buildCleanQuery(text);
        cleanQueryLine.textContent = cleanQuery
          ? "Cleaned query: " + cleanQuery
          : "Cleaned query: (nothing usable found)";

        if (cleanQuery) {
          const gq = `site:discogs.com ${cleanQuery}`;
          currentGoogleQuery = gq;
          googleQueryLine.textContent = "Google query: " + gq;
        } else {
          googleQueryLine.textContent = "Google query: (none – not enough text)";
        }

        if (!cleanQuery) {
          const msg = "Not enough text to search. Try a clearer photo of the label.";
          matchStatus.textContent = msg;
          processingStatus.textContent = msg;
          statusText.textContent = msg;
          app.classList.remove("show-processing");
          app.classList.add("show-results");
          return;
        }

        const res = await fetch(
          "/.netlify/functions/discogsSearch?query=" + encodeURIComponent(cleanQuery)
        );

        if (!res.ok) {
          const errText = await res.text();
          console.error("discogsSearch error:", errText);
          matchStatus.textContent = "Lookup error: " + res.status;
          processingStatus.textContent = "Lookup error: " + res.status;
          statusText.textContent = "Lookup error: " + res.status;

          app.classList.remove("show-processing");
          app.classList.add("show-results");
          return;
        }

        const result = await res.json();

        if (result.primaryGoogleQuery) {
          currentGoogleQuery = result.primaryGoogleQuery;
          googleQueryLine.textContent = "Google query: " + result.primaryGoogleQuery;
        }

        matchStatus.textContent = "Match found (via Google + Discogs).";

        const fullTitle = result.title || "";
        let artist = "";
        let title = "";

        if (fullTitle.includes(" – ")) {
          [artist, title] = fullTitle.split(" – ", 2);
        } else if (fullTitle.includes(" - ")) {
          [artist, title] = fullTitle.split(" - ", 2);
        } else {
          title = fullTitle;
        }

        albumArtist.textContent = artist || "Discogs match";
        albumTitle.textContent = title || "(title unknown)";

        currentDiscogsUrl = result.discogsUrl || "";

        if (result.coverImage) {
          // IMPORTANT: cover always loads without CORS so it reliably displays
          discogsCover.removeAttribute("crossorigin");
          discogsCover.src = result.coverImage;

          // Optional: try to sample the cover color via a separate CORS image (won't affect display)
          trySampleCoverColor(result.coverImage);

          // Update gradient now (label-driven), and again if sampler succeeds
          updateResultsGradient();
        } else {
          discogsCover.removeAttribute("src");
          coverSamplerImg = null;
          updateResultsGradient();
        }

        processingStatus.textContent = "Done.";
        statusText.textContent = "Done.";

        app.classList.remove("show-processing");
        app.classList.add("show-results");
      } catch (err) {
        console.error(err);
        const msg = "Error during OCR or lookup.";
        processingStatus.textContent = msg;
        statusText.textContent = msg;
        matchStatus.textContent = msg;
        app.classList.remove("show-processing");
        app.classList.add("show-results");
      }
    }

    infoButton.addEventListener("click", () => {
      overlay.classList.add("open");
      overlay.setAttribute("aria-hidden", "false");
    });
    overlayClose.addEventListener("click", () => {
      overlay.classList.remove("open");
      overlay.setAttribute("aria-hidden", "true");
    });
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.classList.remove("open");
        overlay.setAttribute("aria-hidden", "true");
      }
    });

    function openDiscogs() {
      if (!currentDiscogsUrl) return;
      window.open(currentDiscogsUrl, "_blank", "noopener");
    }
    discogsButton.addEventListener("click", openDiscogs);
    overlayDiscogsButton.addEventListener("click", openDiscogs);

    /* =========================================================
       Dynamic results gradient color (dominant color + readability)
       ========================================================= */

    function setResultsAccentRgb(rgb) {
      document.documentElement.style.setProperty("--results-rgb", `${rgb[0]}, ${rgb[1]}, ${rgb[2]}`);
    }

    function trySampleCoverColor(url) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        coverSamplerImg = img;
        updateResultsGradient();
      };
      img.onerror = () => {
        // CORS failed or host blocked it — no problem; keep label-based color
        coverSamplerImg = null;
      };
      img.src = url;
    }

    function updateResultsGradient() {
      const sources = [];

      // Always prefer label (local data URL, never CORS-tainted)
      if (currentLabelDataUrl) sources.push({ type: "dataUrl", value: currentLabelDataUrl, weight: 1.2 });

      // If the cover sampler succeeded (with CORS), blend it in
      if (coverSamplerImg) sources.push({ type: "imgEl", value: coverSamplerImg, weight: 1.0 });

      if (!sources.length) {
        setResultsAccentRgb([180, 0, 0]);
        return;
      }

      const rgb = dominantRgbFromSources(sources);
      const safe = ensureReadableOnWhite(rgb);
      setResultsAccentRgb(safe);
    }

    function dominantRgbFromSources(sources) {
      const buckets = new Map();

      for (const s of sources) {
        try {
          const imageData = getPixelsFromSource(s);
          if (!imageData) continue;

          const data = imageData.data;
          for (let i = 0; i < data.length; i += 4) {
            const a = data[i + 3];
            if (a < 64) continue;

            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const sat = max - min;
            const bright = (r + g + b) / 3;

            // Ignore near-black and glare whites
            if (bright < 18) continue;
            if (bright > 245 && sat < 10) continue;

            // Ignore very low-sat bright pixels
            if (sat < 8 && bright > 180) continue;

            // Quantize (5 bits/channel)
            const rq = r >> 3;
            const gq = g >> 3;
            const bq = b >> 3;
            const key = (rq << 10) | (gq << 5) | bq;

            const add = (s.weight || 1);
            buckets.set(key, (buckets.get(key) || 0) + add);
          }
        } catch (e) {
          // ignore failures per-source
        }
      }

      if (!buckets.size) return [18, 18, 18];

      let bestKey = null;
      let bestCount = -1;
      for (const [k, c] of buckets.entries()) {
        if (c > bestCount) {
          bestCount = c;
          bestKey = k;
        }
      }

      const rq = (bestKey >> 10) & 31;
      const gq = (bestKey >> 5) & 31;
      const bq = bestKey & 31;

      // De-quantize to center of bin
      return [
        Math.min(255, (rq << 3) + 4),
        Math.min(255, (gq << 3) + 4),
        Math.min(255, (bq << 3) + 4)
      ];
    }

    function getPixelsFromSource(source) {
      const sampleSize = 72;
      const tmp = document.createElement("canvas");
      tmp.width = sampleSize;
      tmp.height = sampleSize;
      const tctx = tmp.getContext("2d", { willReadFrequently: true });

      if (source.type === "dataUrl") {
        // data URLs are local; load quickly, but still async — so we do a small sync-ish shortcut:
        // draw from an Image that we know is very likely cached; if not complete, skip this pass.
        const img = new Image();
        img.src = source.value;
        if (!img.complete) return null;
        tctx.drawImage(img, 0, 0, sampleSize, sampleSize);
        return tctx.getImageData(0, 0, sampleSize, sampleSize);
      }

      if (source.type === "imgEl") {
        const imgEl = source.value;
        if (!imgEl.complete || !imgEl.naturalWidth) return null;
        tctx.drawImage(imgEl, 0, 0, sampleSize, sampleSize);
        return tctx.getImageData(0, 0, sampleSize, sampleSize);
      }

      return null;
    }

    function ensureReadableOnWhite(rgb) {
      const [r, g, b] = rgb;

      // If dominant is basically white, use dark gray
      if (r > 235 && g > 235 && b > 235) return [18, 18, 18];

      // Darken until contrast with white is decent
      let out = [r, g, b];
      let tries = 0;
      while (contrastRatio(out, [255, 255, 255]) < 4.5 && tries < 12) {
        out = darkenRgb(out, 0.08);
        tries++;
      }

      if (contrastRatio(out, [255, 255, 255]) < 4.5) return [18, 18, 18];
      return out;
    }

    function darkenRgb(rgb, amount) {
      const [r, g, b] = rgb;
      return [
        Math.max(0, Math.round(r * (1 - amount))),
        Math.max(0, Math.round(g * (1 - amount))),
        Math.max(0, Math.round(b * (1 - amount)))
      ];
    }

    function contrastRatio(rgb1, rgb2) {
      const L1 = relLuminance(rgb1);
      const L2 = relLuminance(rgb2);
      const lighter = Math.max(L1, L2);
      const darker = Math.min(L1, L2);
      return (lighter + 0.05) / (darker + 0.05);
    }

    function relLuminance(rgb) {
      const [r, g, b] = rgb.map(v => v / 255);
      const R = (r <= 0.03928) ? (r / 12.92) : Math.pow((r + 0.055) / 1.055, 2.4);
      const G = (g <= 0.03928) ? (g / 12.92) : Math.pow((g + 0.055) / 1.055, 2.4);
      const B = (b <= 0.03928) ? (b / 12.92) : Math.pow((b + 0.055) / 1.055, 2.4);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }
  </script>
</body>
</html>
