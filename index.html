<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>33⅓</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 1rem;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f7f7f7;
      color: #111;
    }
    h1 { font-size: 1.4rem; margin-bottom: 0.25rem; }
    h2 { font-size: 1.1rem; margin: 1rem 0 0.4rem; }
    p  { margin: 0.25rem 0 0.5rem; }

    .uploader {
      margin: 0.75rem 0 0.5rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    input[type="file"] { display: none; }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 0.6rem 1.2rem;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      background: #111;
      color: #fff;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      text-align: center;
      display: inline-block;
    }
    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    canvas {
      width: 100%;
      max-width: 480px;
      display: block;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      background: #000;
      margin: 0.25rem 0;
    }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: Menlo, Monaco, Consolas, "SF Mono", monospace;
      background: #fff;
      padding: 0.75rem;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      font-size: 0.8rem;
      max-height: 220px;
      overflow: auto;
    }

    a {
      color: #0055ff;
      word-break: break-all;
    }

    .status {
      font-size: 0.8rem;
      color: #555;
      margin-top: 0.25rem;
    }

    .query-preview {
      font-size: 0.8rem;
      color: #333;
      margin-top: 0.25rem;
      font-family: Menlo, Monaco, Consolas, "SF Mono", monospace;
    }

    .result-card {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      max-width: 480px;
    }
    .result-card img {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      display: block;
    }
    .result-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
  </style>
</head>
<body>
  <h1>33⅓</h1>
  <p>
    Take a photo of the record label so it fills most of the frame. The app will:
    OCR the text → clean it → call a Netlify function → fetch the top Discogs match + cover.
  </p>

  <div class="uploader">
    <label for="photoInput" class="btn">Take / Choose Photo</label>
    <input id="photoInput" type="file" accept="image/*" capture="environment" />
    <span id="fileName" style="font-size:0.8rem;color:#555;"></span>
  </div>

  <h2>Cropped Label (what OCR sees)</h2>
  <canvas id="canvas"></canvas>

  <h2>OCR Result</h2>
  <div class="status" id="statusText">Waiting for a photo…</div>
  <pre id="ocrText"></pre>
  <div id="queryPreview" class="query-preview"></div>

  <div id="discogsResult" class="result-card" style="display:none;">
    <div class="result-title" id="discogsTitle"></div>
    <img id="discogsCover" alt="Album cover" style="display:none;" />
    <div id="discogsLink"></div>
    <div style="font-size:0.75rem;color:#777;margin-top:0.25rem;" id="discogsMeta"></div>
  </div>

  <canvas id="fullCanvas" style="display:none;"></canvas>

  <script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <script>
    const photoInput   = document.getElementById("photoInput");
    const fileName     = document.getElementById("fileName");
    const canvas       = document.getElementById("canvas");
    const fullCanvas   = document.getElementById("fullCanvas");
    const statusText   = document.getElementById("statusText");
    const ocrText      = document.getElementById("ocrText");
    const queryPreview = document.getElementById("queryPreview");

    const discogsCard  = document.getElementById("discogsResult");
    const discogsTitle = document.getElementById("discogsTitle");
    const discogsCover = document.getElementById("discogsCover");
    const discogsLink  = document.getElementById("discogsLink");
    const discogsMeta  = document.getElementById("discogsMeta");

    photoInput.addEventListener("change", handlePhoto);

    function handlePhoto(evt) {
      const file = evt.target.files && evt.target.files[0];
      if (!file) return;

      fileName.textContent = file.name || "New photo";
      statusText.textContent = "Loading image…";
      ocrText.textContent = "";
      queryPreview.textContent = "";
      discogsCard.style.display = "none";

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => processImage(img);
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function processImage(img) {
      const maxDim = 1600;
      let w = img.width;
      let h = img.height;
      const scale = Math.min(1, maxDim / Math.max(w, h));
      w = Math.round(w * scale);
      h = Math.round(h * scale);

      fullCanvas.width = w;
      fullCanvas.height = h;
      const fctx = fullCanvas.getContext("2d");
      fctx.drawImage(img, 0, 0, w, h);

      const labelSize = Math.round(Math.min(w, h) * 0.9);
      const cx = Math.round((w - labelSize) / 2);
      const cy = Math.round((h - labelSize) / 2);

      const TARGET = 1024;
      const labelCanvas = document.createElement("canvas");
      labelCanvas.width = TARGET;
      labelCanvas.height = TARGET;
      const lctx = labelCanvas.getContext("2d");

      lctx.drawImage(
        fullCanvas,
        cx, cy, labelSize, labelSize,
        0, 0, TARGET, TARGET
      );

      const imgData = lctx.getImageData(0, 0, TARGET, TARGET);
      const pixels = imgData.data;

      let min = 255, max = 0;
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
        const gray = 0.3*r + 0.59*g + 0.11*b;
        if (gray < min) min = gray;
        if (gray > max) max = gray;
      }
      const range = Math.max(1, max - min);

      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
        const gray = 0.3*r + 0.59*g + 0.11*b;
        const norm = (gray - min) / range;
        const v = Math.max(0, Math.min(255, norm * 255));
        pixels[i] = pixels[i+1] = pixels[i+2] = v;
      }
      lctx.putImageData(imgData, 0, 0);

      canvas.width = TARGET;
      canvas.height = TARGET;
      const showCtx = canvas.getContext("2d");
      showCtx.drawImage(labelCanvas, 0, 0, TARGET, TARGET);

      const dataUrl = labelCanvas.toDataURL("image/png");
      runOCR(dataUrl);
    }

    function buildSearchQuery(rawText) {
      if (!rawText) return "";
      let text = rawText.replace(/\s+/g, " ");
      let rawTokens = text.split(" ").map(t =>
        t.replace(/[^A-Za-z0-9']/g, "")
      );

      const stopwords = new Set([
        "WITH","AND","THE","OF","INC","LTD","SIDE","HIGH","FIDELITY",
        "STEREO","MONO","RECORDS","RECORD","COMPANY","LIMITED",
        "STEREOPHONIC","LONG","PLAY","MICROGROOVE","MADE","IN",
        "NEW","YORK","N","J","USA","ALBUM"
      ]);

      const cleanTokens = [];
      const seen = new Set();

      for (let tok of rawTokens) {
        if (!tok) continue;
        const upper = tok.toUpperCase();
        if (upper.length < 3) continue;
        if (/^\d+$/.test(upper) && upper.length < 4) continue;
        if (seen.has(upper)) continue;
        if (stopwords.has(upper)) continue;

        seen.add(upper);
        cleanTokens.push(tok);
        if (cleanTokens.length >= 12) break;
      }

      return cleanTokens.join(" ");
    }

    async function runOCR(dataUrl) {
      statusText.textContent = "Running OCR…";
      ocrText.textContent = "";
      discogsCard.style.display = "none";

      try {
        const { data } = await Tesseract.recognize(dataUrl, "eng", {
          tessedit_pageseg_mode: 6
        });
        const raw = (data.text || "").trim();
        ocrText.textContent = raw || "[no text detected]";

        const query = buildSearchQuery(raw);
        if (!query) {
          statusText.textContent =
            "OCR ran, but no good words were found. Try another photo.";
          queryPreview.textContent = "";
          return;
        }

        queryPreview.textContent = "Cleaned query: " + query;
        statusText.textContent = "Looking up Discogs match…";

        const res = await fetch(
          "/.netlify/functions/discogsSearch?query=" +
          encodeURIComponent(query)
        );

        if (!res.ok) {
          const errText = await res.text();
          statusText.textContent = "Lookup error: " + res.status;
          console.error("discogsSearch error:", errText);
          return;
        }

        const result = await res.json();
        statusText.textContent = "Match found (via Google + Discogs).";

        discogsTitle.textContent = result.title || "Discogs match";
        discogsLink.innerHTML =
          'Discogs: <a href="' +
          result.discogsUrl +
          '" target="_blank">' +
          result.discogsUrl +
          "</a>";

        discogsMeta.textContent = "Google query: " + result.googleQuery;

        if (result.coverImage) {
          discogsCover.src = result.coverImage;
          discogsCover.style.display = "block";
        } else {
          discogsCover.style.display = "none";
        }

        discogsCard.style.display = "block";
      } catch (err) {
        console.error(err);
        statusText.textContent = "OCR or lookup error. Try another photo.";
      }
    }
  </script>
</body>
</html>
