<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>33⅓ – Label Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>

  <style>
    :root {
      --bg: #f4f4f4;
      --card: #ffffff;
      --accent: #111111;
      --accent-soft: #222222;
      --text-main: #111111;
      --text-muted: #666666;
      --radius-lg: 20px;
      --shadow-soft: 0 16px 40px rgba(0, 0, 0, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(circle at top left, #ececec, #e1e1e1);
      color: var(--text-main);
    }

    .shell {
      max-width: 720px;
      margin: 0 auto 64px auto;
      background: var(--card);
      border-radius: 32px;
      padding: 24px 24px 32px;
      box-shadow: var(--shadow-soft);
    }

    header {
      margin-bottom: 24px;
    }

    .logo-row {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
    }

    h1 {
      font-size: 32px;
      letter-spacing: 0.04em;
      margin: 0;
      font-weight: 800;
    }

    .subtitle {
      margin-top: 8px;
      font-size: 14px;
      line-height: 1.4;
      color: var(--text-muted);
    }

    .picker-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .btn-primary {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 20px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: var(--accent);
      color: white;
      font-size: 15px;
      font-weight: 600;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
      transition: transform 0.05s ease-out, box-shadow 0.05s ease-out,
        background 0.15s ease-out;
    }

    .btn-primary:active {
      transform: translateY(1px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
    }

    .file-name {
      font-size: 13px;
      color: var(--text-muted);
    }

    h2 {
      font-size: 18px;
      margin: 24px 0 10px;
    }

    canvas {
      width: 100%;
      max-height: 520px;
      border-radius: 24px;
      display: block;
      background: #000;
      object-fit: contain;
    }

    .status {
      margin-top: 8px;
      font-size: 14px;
      color: var(--text-muted);
    }

    textarea {
      width: 100%;
      min-height: 160px;
      border-radius: 16px;
      border: 1px solid #ddd;
      padding: 12px;
      font-size: 13px;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      resize: vertical;
      background: #fafafa;
    }

    .meta-line {
      margin-top: 8px;
      font-size: 13px;
      color: var(--text-muted);
      word-break: break-word;
    }

    .discogs-card {
      margin-top: 24px;
      border-radius: 24px;
      padding: 16px;
      background: #f7f7f7;
      display: none;
    }

    .discogs-title {
      font-size: 17px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .discogs-layout {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
    }

    .discogs-cover {
      width: 160px;
      border-radius: 14px;
      object-fit: cover;
      background: #ddd;
      flex-shrink: 0;
    }

    .discogs-info {
      flex: 1 1 200px;
      font-size: 13px;
    }

    a {
      color: #0054d6;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      .shell {
        padding: 20px 16px 28px;
        border-radius: 24px;
      }

      h1 {
        font-size: 26px;
      }

      .discogs-cover {
        width: 130px;
      }
    }
  </style>
</head>

<body>
  <div class="shell">
    <header>
      <div class="logo-row">
        <h1>33⅓</h1>
      </div>
      <p class="subtitle">
        Take a photo of the record label so it fills most of the frame.
        The app will: OCR the text → clean it → call a Netlify function →
        fetch the top Discogs match + cover.
      </p>
    </header>

    <section>
      <div class="picker-row">
        <button class="btn-primary" id="pickButton">
          Take / Choose Photo
        </button>
        <span class="file-name" id="fileName">No file selected</span>
        <input
          type="file"
          id="fileInput"
          accept="image/*"
          capture="environment"
          style="display: none"
        />
      </div>
    </section>

    <section>
      <h2>Cropped Label (what OCR sees)</h2>
      <canvas id="labelCanvas"></canvas>
      <div class="status" id="statusText">Waiting for a photo…</div>
    </section>

    <section>
      <h2>OCR Result</h2>
      <div class="status" id="matchStatus"></div>
      <textarea id="ocrOutput" readonly></textarea>
      <div class="meta-line" id="cleanQueryLine"></div>
    </section>

    <section class="discogs-card" id="discogsCard">
      <div class="discogs-title" id="discogsTitle"></div>
      <div class="discogs-layout">
        <img
          id="discogsCover"
          class="discogs-cover"
          alt="Album cover"
          src=""
        />
        <div class="discogs-info">
          <div id="discogsLink"></div>
          <div class="meta-line" id="discogsMeta"></div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const fileInput = document.getElementById("fileInput");
    const pickButton = document.getElementById("pickButton");
    const fileNameSpan = document.getElementById("fileName");
    const canvas = document.getElementById("labelCanvas");
    const ctx = canvas.getContext("2d");

    const statusText = document.getElementById("statusText");
    const matchStatus = document.getElementById("matchStatus");
    const ocrOutput = document.getElementById("ocrOutput");
    const cleanQueryLine = document.getElementById("cleanQueryLine");

    const discogsCard = document.getElementById("discogsCard");
    const discogsTitle = document.getElementById("discogsTitle");
    const discogsCover = document.getElementById("discogsCover");
    const discogsLink = document.getElementById("discogsLink");
    const discogsMeta = document.getElementById("discogsMeta");

    pickButton.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;

      fileNameSpan.textContent = file.name;
      discogsCard.style.display = "none";
      matchStatus.textContent = "";
      ocrOutput.value = "";
      cleanQueryLine.textContent = "";
      statusText.textContent = "Loading image…";

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          processImage(img);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

    function processImage(img) {
      // Crop to center square where label lives
      const size = Math.min(img.width, img.height);
      const sx = (img.width - size) / 2;
      const sy = (img.height - size) / 2;

      canvas.width = size;
      canvas.height = size;
      ctx.drawImage(img, sx, sy, size, size, 0, 0, size, size);

      // Simple grayscale for OCR (no harsh thresholding)
      const imageData = ctx.getImageData(0, 0, size, size);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
        data[i] = data[i + 1] = data[i + 2] = gray;
      }
      ctx.putImageData(imageData, 0, 0);

      statusText.textContent = "Running OCR…";
      runOCR();
    }

    function buildCleanQuery(rawText) {
      // Keep lines & words that look like titles, artists, songs, cat nos etc.
      const lines = rawText.split(/\r?\n/);
      const tokens = [];

      for (let line of lines) {
        line = line
          .replace(/[^A-Za-z0-9'&()\- ]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();
        if (!line) continue;

        const words = line.split(" ");
        const goodWords = words.filter((w) => {
          if (!w) return false;
          if (/^\d+$/.test(w)) return true; // numbers (cat#, times)
          return w.length > 2;
        });

        if (goodWords.length) {
          tokens.push(...goodWords);
        }
      }

      // Deduplicate while preserving order
      const seen = new Set();
      const final = [];
      for (let w of tokens) {
        const key = w.toUpperCase();
        if (!seen.has(key)) {
          seen.add(key);
          final.push(w);
        }
      }
      return final.join(" ");
    }

    async function runOCR() {
      try {
        const { data } = await Tesseract.recognize(canvas, "eng", {
          logger: (m) => {
            if (m.status === "recognizing text" && m.progress) {
              const pct = Math.round(m.progress * 100);
              statusText.textContent = `Running OCR… ${pct}%`;
            }
          },
        });

        const text = data.text || "";
        ocrOutput.value = text.trim();
        statusText.textContent = "OCR complete. Trying to identify record…";

        const cleanQuery = buildCleanQuery(text);
        cleanQueryLine.textContent = cleanQuery
          ? "Cleaned query: " + cleanQuery
          : "Cleaned query: (nothing usable found)";
        if (!cleanQuery) {
          matchStatus.textContent =
            "Not enough text to search. Try a clearer photo.";
          return;
        }

        // Call Netlify function with cleaned query
        const res = await fetch(
          "/.netlify/functions/discogsSearch?query=" +
            encodeURIComponent(cleanQuery)
        );

        if (!res.ok) {
          const errText = await res.text();
          matchStatus.textContent = "Lookup error: " + res.status;
          console.error("discogsSearch error:", errText);
          discogsCard.style.display = "none";
          return;
        }

        const result = await res.json();
        matchStatus.textContent = "Match found (via Google + Discogs).";

        discogsTitle.textContent =
          result.title || "Discogs match";

        discogsLink.innerHTML =
          'Discogs: <a href="' +
          result.discogsUrl +
          '" target="_blank" rel="noopener noreferrer">' +
          result.discogsUrl +
          "</a>";

        const googleQuery =
          result.primaryGoogleQuery ||
          result.googleQuery ||
          "";

        discogsMeta.textContent = googleQuery
          ? "Google query: " + googleQuery
          : "";

        if (result.coverImage) {
          discogsCover.src = result.coverImage;
          discogsCover.style.display = "block";
        } else {
          discogsCover.style.display = "none";
        }

        discogsCard.style.display = "block";
        statusText.textContent = "Done.";
      } catch (err) {
        console.error(err);
        statusText.textContent = "Error during OCR or lookup.";
        matchStatus.textContent = "";
        discogsCard.style.display = "none";
      }
    }
  </script>
</body>
</html>
